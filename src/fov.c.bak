//-----------------------------LICENSE NOTICE--------------------------------
//  This file is part of CPCRogue: An Amstrad CPC rogue like game
//  Copyright (C) 2019 Andrés Mata Bretón (@FlautinesMata)
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published
//  by the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//---------------------------------------------------------------------------
#include <cpctelera.h>
#include <stdbool.h>
#include "fov.h"
#include "consts.h"
#include "rect.h"
#include "aux_math.h"
#include "game_map.h"
#include "entity.h"

#ifdef DEBUG
#include "assert.h"
#endif


// forward declaration private fn.
void compute_fov_shadow();
void compute(u8 octant, i8 o_x, i8 o_y, i8 x,
  i8 top_x, i8 top_y, i8 btm_x, i8 btm_y);

extern bool fov_changed;
extern struct TEntity *player;


/*! \brief Visibility map, implemented as a bitarray */
//extern CPCT_1BITARRAY(vis_map,MAP_WIDTH*MAP_HEIGHT);
CPCT_1BITARRAY(vis_map,MAP_WIDTH*MAP_HEIGHT);

/*
 * Reset the visibility map to all *not visible*. In current implementation
 * what it does is zeroes all bytes in the \ref vis_map array.
 */
void init_vismap () {
  cpct_memset (vis_map, 0, sizeof (vis_map));
}

/*!
 * \param x,y Visibility map coordinates to set as visible
 */
void set_visible (i8 x, i8 y) {
#ifdef DEBUG
  assert (x < MAP_WIDTH && x >= 0);
  assert (y < MAP_HEIGHT && y >= 0);
#endif
  cpct_setBit (vis_map, 1, y*MAP_WIDTH+x);
}

/*!
 * \param x,y Visibility map coordinates to set as visible
 *
 * \return 1 if the tile is visible, 0 otherwise
 */
bool is_visible (i8 x, i8 y) {
#ifdef DEBUG
  assert (x < MAP_WIDTH && x >= 0);
  assert (y < MAP_HEIGHT && y >= 0);
#endif
  return cpct_getBit (vis_map, y*MAP_WIDTH+x);
}

/*!
 * Computes Light of Sight from a specific point using basic *ray-casting*.
 * Imaginary “rays” are casted away from the specified position and sent in
 * every direction. If they cross a new tile, it is displayed. If this tile
 * is an obstacle, the rays stop here. Otherwise, it goes through the next
 * tile, and so on.
 *
 * \param origin_x, origin_y Starting point, usually player position
 * \param range Max distance to compute, usually player's field of view
 */
void compute_fov () {
  compute_fov_shadow();
}

void compute_fov_shadow() {
  // Do nothing if fov does not need to be re-computed
  if (fov_changed) {

    //fov_changed = false;
    init_vismap ();

    // Start point is visible by definition
    set_visible (player->x, player->y);

    for(u8 octant=0; octant<8; octant++)
      compute(octant, player->x, player->y, 1,
        1,1, 0,1);

  } // if fov_changed
}

void compute(u8 octant, i8 o_x, i8 o_y, i8 x,
  i8 top_x, i8 top_y, i8 btm_x, i8 btm_y)
{

  i8 topY, bottomY, wasOpaque;
  i8 tx, ty;
  i8 new_btm_x, new_btm_y;
  bool inRange, isOpaque;

  for(; x <= FOV_RADIUS; x++) // rangeLimit < 0 || x <= rangeLimit
  {
    // compute the Y coordinates where the top vector leaves the column (on the right) and where the bottom vector
    // enters the column (on the left). this equals (x+0.5)*top+0.5 and (x-0.5)*bottom+0.5 respectively, which can
    // be computed like (x+0.5)*top+0.5 = (2(x+0.5)*top+1)/2 = ((2x+1)*top+1)/2 to avoid floating point math
    topY = top_x == 1 ? x : ((x*2+1) * top_y + top_x - 1) / (top_x*2); // the rounding is a bit tricky, though
    bottomY = btm_y == 0 ? 0 : ((x*2-1) * btm_y + btm_x) / (btm_x*2);

    wasOpaque = -1; // 0:false, 1:true, -1:not applicable
    for(i8 y=topY; y >= bottomY; y--)
    {
      tx = o_x, ty = o_y;
      switch(octant) // translate local coordinates to map coordinates
      {
        case 0: tx += x; ty -= y; break;
        case 1: tx += y; ty -= x; break;
        case 2: tx -= y; ty -= x; break;
        case 3: tx -= x; ty -= y; break;
        case 4: tx -= x; ty += y; break;
        case 5: tx -= y; ty += x; break;
        case 6: tx += y; ty += x; break;
        case 7: tx += x; ty += y; break;
      }

      inRange = distance_sqr(o_x, o_y, tx, ty) <= FOV_R2;
      if(inRange) set_visible(tx, ty);
      // NOTE: use the next line instead if you want the algorithm to be symmetrical
      // if(inRange && (y != topY || top.Y*x >= top.X*y) && (y != bottomY || bottom.Y*x <= bottom.X*y)) SetVisible(tx, ty);

      isOpaque = !inRange || tile_blocks_light(tx, ty);
      if(x != FOV_RADIUS)
      {
        if(isOpaque)
        {
          if(wasOpaque == 0) // if we found a transition from clear to opaque, this sector is done in this column, so
          {                  // adjust the bottom vector upwards and continue processing it in the next column.
            new_btm_y = y*2+1;
            new_btm_x = x*2-1; // (x*2-1, y*2+1) is a vector to the top-left of the opaque tile
            if(!inRange || y == bottomY) { btm_y = new_btm_y; break; } // don't recurse unless we have to
            else compute(octant, o_x, o_y, x+1,
              top_x, top_y, new_btm_x, new_btm_y);
          }
          wasOpaque = 1;
        }
        else // adjust top vector downwards and continue if we found a transition from opaque to clear
        {    // (x*2+1, y*2+1) is the top-right corner of the clear tile (i.e. the bottom-right of the opaque tile)
          if(wasOpaque > 0) {
            top_y = y*2+1;
            top_x = x*2+1;
          }
          wasOpaque = 0;
        }
      }
    }
    if(wasOpaque != 0) break; // if the column ended in a clear tile, continue processing the current sector
  }

}

/*
void compute_fov_basic () {
  extern bool fov_changed;
  extern struct TEntity *player;
  struct TRect area;

  // Do nothing if fov does not need to be re-computed
  if (fov_changed) {

    fov_changed = false;
    init_vismap ();
    // Start point is visible by definition
    set_visible (player->x, player->y);

    // Create a Rect around the origin
    rect_create (&area, player->x - FOV_RADIUS, player->y - FOV_RADIUS,
      FOV_R2, FOV_R2);

    if (area.top < 0) area.top = 0;
    if (area.left < 0) area.left = 0;
    if (area.bottom > MAP_HEIGHT-1) area.bottom = MAP_HEIGHT-1;
    if (area.right > MAP_WIDTH-1) area.right = MAP_WIDTH-1;

    // Cast rays towards the top and bottom of the area
    for (i8 x=area.left; x<area.right; ++x) {
  #ifdef DEBUG
      assert (x < MAP_WIDTH && x >= 0);
  #endif
      trace_line (player->x, player->y, x, area.top, FOV_R2);
      trace_line (player->x, player->y, x, area.bottom-1, FOV_R2);
    }

    for (i8 y=area.top+1; y<area.bottom-1; ++y) {
  #ifdef DEBUG
      assert (y < MAP_HEIGHT && y >= 0);
  #endif
      trace_line (player->x, player->y, area.left, y, FOV_R2);
      trace_line (player->x, player->y, area.right-1, y, FOV_R2);
    }
  }
}
*/
/*!
 * Traces a line between two game map points using *Bresenham's* line
 * algorithm. For each tile the line *touches* the FOV information is
 * updated. The line is constrained to *range* distance or the first wall
 * it encounters.
 *
 * \param x1,y1 Origin point coordinates
 * \param x2,y2 Destination point coordinates
 * \param range Max line Distance (usually FOV radius)
 */
/*
void trace_line (i8 x1, i8 y1, i8 x2, i8 y2, u8 range) {

  u8 dx, dy;
  i8 sx, sy;
  i8 error, error2;
  u8 origin_x, origin_y;

  origin_x = x1;
  origin_y = y1;

  dx = x2-x1;
  dy = y2-y1;
  sx = sign (dx);
  sy = sign (dy);
  dx = abs (dx);
  dy = abs (dy);
  error = dx-dy;


  while(1) {
    *ptr++ = x1;
    *ptr++ = y1;
    locate (x1,y1);putchar('#');

    // Exit when we reach target point or we are beyond range distance
    if (x1==x2 && y1==y2) break;

    error2 = error << 1;
    if (error2 > -dx) {
      error -= dy;
      x1 += sx;
    }
    if (error2 < (i8)dx) {
      error += dx;
      y1 += sy;
    }
    //if (manh_distance (origin_x,origin_y, x1,y1) > range)
    if (distance_sqr (origin_x,origin_y, x1,y1) > range)
      break;

    // Set visible every cell we 'touch' along the line
    set_visible (x1,y1);
    // Exit if we found something that blocks light (i.e:wall)
    if (tile_blocks_light (x1, y1)) break;
  }
}
*/